/**
 * GPII Flow Manager Browser Channel Tests
 *
 * Copyright 2013-2020 OCAD University
 * Copyright 2015 Emergya
 * Copyright 2015 Raising the Floor - International
 *
 * Licensed under the New BSD license. You may not use this file except in
 * compliance with this License.
 *
 * You may obtain a copy of the License at
 * https://github.com/GPII/kettle/LICENSE.txt
 */
"use strict";

var fluid = require("infusion"),
    jqUnit = fluid.require("node-jqunit", require, "jqUnit"),
    gpii = fluid.registerNamespace("gpii");

fluid.registerNamespace("gpii.tests.flowManager.browserChannel");

// TODO:  These payloads are based on the "real" solutions 'org.nvda-project'
// and 'org.gnome.orca'.  The reason for the scare-quotes is because the
// solutions are real and declared within the solutions registries used in
// production.  However, the solution registry used in these tests is a mock
// (see ./data/browserChannel_solutionsRegistry.json).
//
// The solutions should be replaced with mock solutions, and associated mock
// preferences, a mock solutions registry, and a mock device context. (Note:
// these tests currently also use a mock device reporter payload, and could
// continue to do so, but updated with new mock data.  See
// ./data/browserChannel_deviceReporter.json.
//
// As a warning: if mock solutions and mock preferences are used, and the
// preferences file is located in %gpii-universal/tests/data/preferences, then
// the preferences will not validate -- see:
// %gpii-universal/gpii/node_modules/solutionsRegistry/test/SettingsPayloadTests.js
//
// GpiiKeys and prefsSafes are generated from those test preferences
// (%gpii-universal/tests/data/preferences) and then used by the couchDB test
// harness:  It is a convenient place to put any test preferences.  The
// issue is that using mock solutions/preferences will create validation issues
// elsewhere and that will have to be addressed somehow.
gpii.tests.flowManager.browserChannel.payloads = {
    "com.tycoon.dummyApp": {
        "volume": 50,
        "voice": "Throckmorton",
        "magFactor": 2
    },
    "org.freebie.fauxApp": {
        "dictation": true,
        "appCommands": {
            "open": "Open pho app",
            "close": "Close pho app"
        }
    }
};

gpii.tests.flowManager.browserChannel.reportPlatform = function () {
    return {
        id: "win32",
        version: "x86-64"
    };
};

gpii.tests.flowManager.browserChannel.checkConnectionRequest = function (data, request) {
    request.events.onReceiveMessage.addListener(function (message, request) {
        fluid.log("BrowserChannel checkConnectionRequest got onReceiveMessage ", message);
        request.events[message.type].fire(message.payload);
    });
};

gpii.tests.flowManager.browserChannel.checkClients = function (spec) {
    spec = spec || {};
    fluid.each(gpii.tests.flowManager.browserChannel.payloads, function (value, key) {
        var count = spec[key] || 0;
        jqUnit.assertEquals("Count of clients of type " + key, count, Object.keys(gpii.settingsHandlers.webSockets.instance.clients[key] || {}).length);
    });
};

gpii.tests.flowManager.browserChannel.checkErrorResponse = function (gpiiKey, data, request) {
    var expMsg = "Got logout request from user " + gpiiKey + ", but the user noUser is logged in. So ignoring the request.";
    data = JSON.parse(data);
    jqUnit.assertTrue("Received error as expected", data.isError);
    jqUnit.assertEquals("Received message as expected", expMsg, data.message);
    jqUnit.assertEquals("Received error code 409", 409, request.nativeResponse.statusCode);
};

gpii.tests.flowManager.browserChannel.checkPersistentSettings = function (clientId) {
    var expectedSettings = gpii.tests.flowManager.browserChannel.payloads[clientId];
    jqUnit.assertDeepEq("The settings for " + clientId + " in persistence are the expected following logon",
        expectedSettings, gpii.settingsHandlers.webSockets.instance.getSettingsForId(clientId));
};

gpii.tests.flowManager.browserChannel.loginAndSettingsChanged = function (multiArg, spec) {
    fluid.each(spec.clientIds, function (clientId) {
        var expectedSettings = gpii.tests.flowManager.browserChannel.payloads[clientId];
        gpii.tests.flowManager.browserChannel.checkPersistentSettings(clientId);
        jqUnit.assertDeepEq("The settings sent via browserChannel for " + clientId + " are the expected following logon",
            expectedSettings, multiArg[clientId][0]);
    });
    jqUnit.assertEquals("Login response is correct", "User with GPII key " + spec.gpiiKey + " was successfully logged in.", multiArg.login[0]);
};

gpii.tests.flowManager.browserChannel.connectionSucceeded = function (data, solutionId) {
    // TODO: Slight risk of race condition here - this message might not arrive until settings have changed
    jqUnit.assertDeepEq("Right after connecting, the initial settings transmitted for " + solutionId  + " are as in persistence",
        gpii.settingsHandlers.webSockets.instance.getSettingsForId(solutionId),
        data
    );
};

gpii.tests.flowManager.browserChannel.checkRejectedConnection = function (data, solutionId) {
    jqUnit.assertDeepEq("An untrusted solutionId can't make use of the browserChannel", {
        isError: true,
        message: "Rejecting a connection request from '" + solutionId + "'. The solution id was not found in the solutions registry"
    }, data);
};

fluid.defaults("gpii.tests.flowManager.browserChannel.clientHolder", {
    gradeNames: "kettle.test.request.ws",
    path: "/browserChannel",
    port: "{configuration}.options.mainServerPort",
    solutionId: "",
    events: {
        onSettingsChanged: null,
        connectionSucceeded: null
    },
    listeners: {
        connectionSucceeded: {
            funcName: "gpii.tests.flowManager.browserChannel.connectionSucceeded",
            args: ["{arguments}.0", "{that}.options.solutionId"]
        }
    },
    invokers: {
        sendId: {
            func: "{that}.send",
            args: {
                type: "connect",
                payload: {
                    solutionId: "{that}.options.solutionId"
                }
            }
        }
    }
});

fluid.defaults("gpii.tests.flowManager.browserChannel.chromeClient", {
    gradeNames: "gpii.tests.flowManager.browserChannel.clientHolder",
    solutionId: "com.tycoon.dummyApp"
});

fluid.defaults("gpii.tests.flowManager.browserChannel.firefoxClient", {
    gradeNames: "gpii.tests.flowManager.browserChannel.clientHolder",
    solutionId: "org.freebie.fauxApp"
});

fluid.defaults("gpii.tests.flowManager.browserChannel.unauthorizedClient", {
    gradeNames: "gpii.tests.flowManager.browserChannel.clientHolder",
    solutionId: "com.unauthorized.app"
});

fluid.defaults("gpii.tests.flowManager.browserChannel.gpiiKeyRequest", {
    gradeNames: "kettle.test.request.http",
    termMap: {
        gpiiKey: "{that}.options.gpiiKey"
    }
});

fluid.defaults("gpii.tests.flowManager.browserChannel.loginRequest", {
    gradeNames: "gpii.tests.flowManager.browserChannel.gpiiKeyRequest",
    path: "/user/%gpiiKey/login"
});

gpii.tests.flowManager.browserChannel.testLogoutResponse = function (data, gpiiKey) {
    jqUnit.assertEquals("Response is correct", "User with GPII key " + gpiiKey + " was successfully logged out.", data);
};

fluid.defaults("gpii.tests.flowManager.browserChannel.logoutRequest", {
    gradeNames: "gpii.tests.flowManager.browserChannel.gpiiKeyRequest",
    path: "/user/%gpiiKey/logout",
    invokers: {
        checkResponse: {
            funcName: "gpii.tests.flowManager.browserChannel.testLogoutResponse",
            args: ["{arguments}.0", "{that}.options.gpiiKey"]
        }
    }
});

gpii.tests.flowManager.browserChannel.testDefs = [{
    name: "Flow Manager Simple BrowserChannel tests",
    expect: 15,
    config: {
        configName: "gpii.flowManager.tests.browserChannel.config",
        configPath: "%flowManager/test/configs"
    },
    events: {
        loginAndSettingsChangedDummyApp: {
            events: {
                login: "{loginDummyApp}.events.onComplete",
                "com.tycoon.dummyApp": "{clientOne}.events.onSettingsChanged"
            },
            args: ["{arguments}", {
                gpiiKey: "{loginDummyApp}.options.gpiiKey",
                clientIds: ["com.tycoon.dummyApp"]
            }]
        }
    },
    components: {
        clientOne: {
            type: "gpii.tests.flowManager.browserChannel.chromeClient"
        },
        loginDummyApp: {
            type: "gpii.tests.flowManager.browserChannel.loginRequest",
            options: {
                gpiiKey: "dummyApp"
            }
        },
        logoutDummyApp1: {
            type: "gpii.tests.flowManager.browserChannel.logoutRequest",
            options: {
                gpiiKey: "dummyApp"
            }
        },
        logoutDummyApp2: {
            type: "gpii.tests.flowManager.browserChannel.logoutRequest",
            options: {
                gpiiKey: "dummyApp"
            }
        }
    },
    sequence: [{
        func: "gpii.tests.flowManager.browserChannel.checkClients"
    }, {
        func: "{clientOne}.connect"
    }, {
        event: "{clientOne}.events.onConnect",
        listener: "fluid.identity"
    }, {
        func: "{clientOne}.sendId"
    }, {
        event: "{clientOne}.events.onReceiveMessage",
        listener: "gpii.tests.flowManager.browserChannel.checkConnectionRequest"
    }, {
        func: "gpii.tests.flowManager.browserChannel.checkClients",
        args: {
            "com.tycoon.dummyApp": 1
        }
    }, {
        func: "{loginDummyApp}.send"
    }, {
        event: "{testCaseHolder}.events.loginAndSettingsChangedDummyApp",
        listener: "gpii.tests.flowManager.browserChannel.loginAndSettingsChanged"
    }, {
        func: "{logoutDummyApp1}.send"
    }, {
        event: "{logoutDummyApp1}.events.onComplete",
        listener: "{logoutDummyApp1}.checkResponse"
    }, {
        func: "gpii.tests.flowManager.browserChannel.checkClients",
        args: {
            "com.tycoon.dummyApp": 1
        }
    }, {
        func: "{clientOne}.disconnect"
    }, {
        func: "{logoutDummyApp2}.send"
    }, {
        event: "{logoutDummyApp2}.events.onComplete",
        listener: "gpii.tests.flowManager.browserChannel.checkErrorResponse",
        args: ["dummyApp", "{arguments}.0", "{arguments}.1"]
    }, {
        func: "gpii.tests.flowManager.browserChannel.checkClients"
    }]
}, {
    name: "Flow Manager BrowserChannel tests",
    expect: 30,
    config: {
        configName: "gpii.flowManager.tests.browserChannel.config",
        configPath: "%flowManager/test/configs"
    },
    events: {
        loginAndSettingsChangedChromeAndFirefox: {
            events: {
                login: "{loginChromeAndFirefox}.events.onComplete",
                "com.tycoon.dummyApp": "{clientTwo}.events.onSettingsChanged",
                "org.freebie.fauxApp": "{clientThree}.events.onSettingsChanged"
            },
            args: ["{arguments}", {
                gpiiKey: "{loginChromeAndFirefox}.options.gpiiKey",
                clientIds: ["com.tycoon.dummyApp", "org.freebie.fauxApp"]
            }]
        }
    },
    components: {
        clientOne: {
            type: "gpii.tests.flowManager.browserChannel.chromeClient"
        },
        clientTwo: {
            type: "gpii.tests.flowManager.browserChannel.chromeClient"
        },
        clientThree: {
            type: "gpii.tests.flowManager.browserChannel.firefoxClient"
        },
        clientFour: {
            type: "gpii.tests.flowManager.browserChannel.unauthorizedClient"
        },
        clientFive: {
            type: "gpii.tests.flowManager.browserChannel.chromeClient"
        },
        loginDummyApp: {
            type: "gpii.tests.flowManager.browserChannel.loginRequest",
            options: {
                gpiiKey: "dummyApp"
            }
        },
        logoutDummyApp1: {
            type: "gpii.tests.flowManager.browserChannel.logoutRequest",
            options: {
                gpiiKey: "DummyApp1"
            }
        },
        logoutDummyApp2: {
            type: "gpii.tests.flowManager.browserChannel.logoutRequest",
            options: {
                gpiiKey: "dummyApp"
            }
        },
        logoutFauxApp: {
            type: "gpii.tests.flowManager.browserChannel.logoutRequest",
            options: {
                gpiiKey: "fauxApp"
            }
        },
        loginChromeAndFirefox: {
            type: "gpii.tests.flowManager.browserChannel.loginRequest",
            options: {
                gpiiKey: "dummy_and_faux"
            }
        },
        logoutChromeAndFirefox: {
            type: "gpii.tests.flowManager.browserChannel.logoutRequest",
            options: {
                gpiiKey: "dummy_and_faux"
            }
        }
    },
    sequence: [{
        func: "gpii.tests.flowManager.browserChannel.checkClients"
    }, {
        func: "{clientOne}.connect"
    }, {
        event: "{clientOne}.events.onConnect",
        listener: "fluid.identity"
    }, {
        func: "{clientOne}.sendId"
    }, {
        event: "{clientOne}.events.onReceiveMessage",
        listener: "gpii.tests.flowManager.browserChannel.checkConnectionRequest"
    }, {
        func: "gpii.tests.flowManager.browserChannel.checkClients",
        args: {
            "com.tycoon.dummyApp": 1
        }
    }, {
        func: "{clientTwo}.connect"
    }, {
        event: "{clientTwo}.events.onConnect",
        listener: "fluid.identity"
    }, {
        func: "{clientTwo}.sendId"
    }, {
        event: "{clientTwo}.events.onReceiveMessage",
        listener: "gpii.tests.flowManager.browserChannel.checkConnectionRequest"
    }, {
        func: "gpii.tests.flowManager.browserChannel.checkClients",
        args: {
            "com.tycoon.dummyApp": 2
        }
    }, {
        func: "{clientThree}.connect"
    }, {
        event: "{clientThree}.events.onConnect",
        listener: "fluid.identity"
    }, {
        func: "{clientThree}.sendId"
    }, {
        event: "{clientThree}.events.onReceiveMessage",
        listener: "gpii.tests.flowManager.browserChannel.checkConnectionRequest"
    }, {
        func: "{clientFour}.connect"
    }, {
        event: "{clientFour}.events.onConnect",
        listener: "fluid.identity"
    }, {
        func: "{clientFour}.sendId"
    }, {
        event: "{clientFour}.events.onReceiveMessage",
        listener: "gpii.tests.flowManager.browserChannel.checkRejectedConnection",
        args: ["{arguments}.0", "{clientFour}.options.solutionId"]
    }, {
        func: "gpii.tests.flowManager.browserChannel.checkClients",
        args: {
            "com.tycoon.dummyApp": 2,
            "org.freebie.fauxApp": 1
        }
    },
    // All three clients now logged in - disconnect client 1 and try a spurious logout
    {
        func: "{clientOne}.disconnect"
    }, {
        func: "{logoutDummyApp1}.send"
    }, {
        event: "{logoutDummyApp1}.events.onComplete",
        listener: "gpii.tests.flowManager.browserChannel.checkErrorResponse",
        args: ["DummyApp1", "{arguments}.0", "{arguments}.1"]
    }, {
        func: "gpii.tests.flowManager.browserChannel.checkClients",
        args: {
            "com.tycoon.dummyApp": 1,
            "org.freebie.fauxApp": 1
        }
    },
    // Log in a user who has settings for two browsers
    {
        func: "{loginChromeAndFirefox}.send"
    }, {
        event: "{testCaseHolder}.events.loginAndSettingsChangedChromeAndFirefox",
        listener: "gpii.tests.flowManager.browserChannel.loginAndSettingsChanged"
    }, {
        func: "{logoutChromeAndFirefox}.send"
    }, {
        event: "{logoutChromeAndFirefox}.events.onComplete",
        listener: "{logoutChromeAndFirefox}.checkResponse"
    }, {
        func: "{clientTwo}.disconnect"
    }, {
        func: "{logoutFauxApp}.send"
    }, {
        event: "{logoutFauxApp}.events.onComplete",
        listener: "gpii.tests.flowManager.browserChannel.checkErrorResponse",
        args: ["fauxApp", "{arguments}.0", "{arguments}.1"]
    }, {
        func: "gpii.tests.flowManager.browserChannel.checkClients",
        args: {
            "org.freebie.fauxApp": 1
        }
    }, {
        func: "{clientThree}.disconnect"
    }, // At this point, zero clients are connected
    {
        func: "{loginDummyApp}.send"
    }, {
        event: "{loginDummyApp}.events.onComplete",
        listener: "gpii.tests.flowManager.browserChannel.loginAndSettingsChanged",
        args: [{ // manually construct multiArg since there is only one event
            login: ["{arguments}.0"]
        }, {
            gpiiKey: "{loginDummyApp}.options.gpiiKey"
        }]
    },  {
        func: "{clientFive}.connect"
    }, {
        event: "{clientFive}.events.onConnect",
        listener: "fluid.identity"
    }, {
        func: "{clientFive}.sendId"
    }, {
        event: "{clientFive}.events.onReceiveMessage",
        listener: "gpii.tests.flowManager.browserChannel.checkConnectionRequest"
    }, {
        func: "gpii.tests.flowManager.browserChannel.checkPersistentSettings",
        args: "com.tycoon.dummyApp"
    }, {
        func: "{clientFive}.disconnect"
    }, {
        func: "{logoutDummyApp2}.send"
    }, {
        event: "{logoutDummyApp2}.events.onComplete",
        listener: "{logoutDummyApp2}.checkResponse"
    }, {
        func: "gpii.tests.flowManager.browserChannel.checkClients"
    }]
}];
